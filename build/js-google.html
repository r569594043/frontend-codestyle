<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Frontend Code Style</title>
    <link rel="stylesheet" href="assets/css/normalize.css">
    <link rel="stylesheet" href="assets/css/md.css">
    <link rel="stylesheet" href="assets/css/github.css">
    <style>
        .container {
            width: 980px;
            margin-right: auto;
            margin-left: auto;
        }
        
        .markdown-body {
            padding: 45px;
            word-wrap: break-word;
            background-color: #fff;
            border: 1px solid #ddd;
            margin-top: 30px;
            margin-bottom: 30px;
            border-radius: 3px;
        }
    </style>
</head>

<body>
    <div class="container">
        <article class="markdown-body">
            <h1 id="google-javascript-style-guide">Google JavaScript Style Guide</h1>
            <h2 id="background">Background</h2>
            <p>JavaScript is the main client-side scripting language used by many of Google&#39;s open-source projects. This style guide is a list of dos and don&#39;ts for JavaScript programs.</p>
            <h2 id="javascript-language-rules">JavaScript Language Rules</h2>
            <h3 id="var">var</h3>
            <p>Declarations with <code>var</code>: Always</p>
            <h4 id="decision-">Decision:</h4>
            <p>When you fail to specify <code>var</code>, the variable gets placed in the global context, potentially clobbering existing values. Also, if there&#39;s no declaration, it&#39;s hard to tell in what scope a variable lives (e.g., it could be in the
                Document or Window just as easily as in the local scope). So always declare with <code>var</code>.</p>
            <h3 id="constants">Constants</h3>
            <ul>
                <li>Use <code>NAMES_LIKE_THIS</code> for constant values.</li>
                <li>Use <code>@const</code> to indicate a constant (non-overwritable) pointer (a variable or property).</li>
                <li>Never use the <a href="#"><code>const</code> keyword</a> as it&#39;s not supported in Internet Explorer.</li>
            </ul>
            <h4 id="decision-">Decision:</h4>
            <h5 id="constant-values">Constant values</h5>
            <p>If a value is intended to be constant and immutable, it should be given a name in <code>CONSTANT_VALUE_CASE</code>. <code>ALL_CAPS</code> additionally implies <code>@const</code> (that the value is not overwritable).</p>
            <p>Primitive types (<code>number</code>, <code>string</code>, <code>boolean</code>) are constant values.</p>
            <p><code>Objects&#39;</code> immutability is more subjective â€” objects should be considered immutable only if they do not demonstrate observable state change. This is not enforced by the compiler.</p>
            <h5 id="constant-pointers-variables-and-properties-">Constant pointers (variables and properties)</h5>
            <p>The <code>@const</code> annotation on a variable or property implies that it is not overwritable. This is enforced by the compiler at build time. This behavior is consistent with the <a href="#"><code>const</code> keyword</a> (which we do not use
                due to the lack of support in Internet Explorer).</p>
            <p>A <code>@const</code> annotation on a method additionally implies that the method cannot not be overridden in subclasses.</p>
            <p>A <code>@const</code> annotation on a constructor implies the class cannot be subclassed (akin to <code>final</code> in Java).</p>
            <h5 id="examples">Examples</h5>
            <p>Note that <code>@const</code> does not necessarily imply <code>CONSTANT_VALUES_CASE</code>. However, <code>CONSTANT_VALUES_CASE</code> <em>does</em> imply <code>@const</code>.</p>
            <pre><code class="lang-javascript">/**
 * <span class="hljs-type">Request</span> timeout <span class="hljs-keyword">in</span> milliseconds.
 * @<span class="hljs-keyword">type</span> {number}
 */
<span class="hljs-title">goog</span>.example.<span class="hljs-type">TIMEOUT_IN_MILLISECONDS</span> = <span class="hljs-number">60</span>;
</code></pre>
            <p>The number of seconds in a minute never changes. It is a constant value. <code>ALL_CAPS</code> also implies <code>@const</code>, so the constant cannot be overwritten.</p>
            <p>The open source compiler will allow the symbol to be overwritten because the constant is not marked as <code>@const</code>.</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">/**
 * Map of URL to response string.
 * <span class="hljs-doctag">@const</span>
 */</span>
MyClass.fetchedUrlCache_ = <span class="hljs-keyword">new</span> goog.structs.Map();
<span class="hljs-comment">/**
 * Class that cannot be subclassed.
 * <span class="hljs-doctag">@const</span>
 * <span class="hljs-doctag">@constructor</span>
 */</span>
sloth.MyFinalClass = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};
</code></pre>
            <p>In this case, the pointer can never be overwritten, but value is highly mutable and not constant (and thus in <code>camelCase</code>, not <code>ALL_CAPS</code>).</p>
            <h3 id="semicolons">Semicolons</h3>
            <p>Always use semicolons.</p>
            <p>Relying on implicit insertion can cause subtle, hard to debug problems. Don&#39;t do it. You&#39;re better than that.</p>
            <p>There are a couple places where missing semicolons are particularly dangerous:</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">// 1.</span>
MyClass.prototype.myMethod = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}  <span class="hljs-comment">// No semicolon here.</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Some initialization code wrapped in a function to create a scope for locals.</span>
})();


<span class="hljs-keyword">var</span> x = {
  <span class="hljs-string">'i'</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">'j'</span>: <span class="hljs-number">2</span>
}  <span class="hljs-comment">// No semicolon here.</span>

<span class="hljs-comment">// 2.  Trying to do one thing on Internet Explorer and another on Firefox.</span>
<span class="hljs-comment">// I know you'd never write code like this, but throw me a bone.</span>
[ffVersion, ieVersion][isIE]();


<span class="hljs-keyword">var</span> THINGS_TO_EAT = [apples, oysters, sprayOnCheese]  <span class="hljs-comment">// No semicolon here.</span>

<span class="hljs-comment">// 3. conditional execution a la bash</span>
<span class="hljs-number">-1</span> == resultOfOperation() || <span class="hljs-keyword">die</span>();
</code></pre>
            <h5 id="so-what-happens-">So what happens?</h5>
            <ol>
                <li>JavaScript error - first the function returning 42 is called with the second function as a parameter, then the number 42 is &quot;called&quot; resulting in an error.</li>
                <li>You will most likely get a &#39;no such property in undefined&#39; error at runtime as it tries to call <code>x[ffVersion, ieVersion][isIE]()</code>.</li>
                <li><code>die</code> is always called since the array minus 1 is <code>NaN</code> which is never equal to anything (not even if <code>resultOfOperation()</code> returns <code>NaN</code>) and <code>THINGS_TO_EAT</code> gets assigned the result of
                    <code>die()</code>.</li>
            </ol>
            <h5 id="why-">Why?</h5>
            <p>JavaScript requires statements to end with a semicolon, except when it thinks it can safely infer their existence. In each of these examples, a function declaration or object or array literal is used inside a statement. The closing brackets are
                not enough to signal the end of the statement. Javascript never ends a statement if the next token is an infix or bracket operator.</p>
            <p>This has really surprised people, so make sure your assignments end with semicolons.</p>
            <h5 id="clarification-semicolons-and-functions">Clarification: Semicolons and functions</h5>
            <p>Semicolons should be included at the end of function expressions, but not at the end of function declarations. The distinction is best illustrated with an example:</p>
            <pre><code class="lang-JavaScript"><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};  <span class="hljs-comment">// semicolon here.</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}  <span class="hljs-comment">// no semicolon here.</span>
</code></pre>
            <h3 id="nested-functions">Nested functions</h3>
            <p>Yes</p>
            <p>Nested functions can be very useful, for example in the creation of continuations and for the task of hiding helper functions. Feel free to use them.</p>
            <h3 id="function-declarations-within-blocks">Function Declarations Within Blocks</h3>
            <p>No</p>
            <p>Do not do this:</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (x) {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{}
}
</code></pre>
            <p>While most script engines support Function Declarations within blocks it is not part of ECMAScript (see <a href="">ECMA-262</a>, clause 13 and 14). Worse implementations are inconsistent with each other and with future EcmaScript proposals. ECMAScript
                only allows for Function Declarations in the root statement list of a script or function. Instead use a variable initialized with a Function Expression to define a function within a block:</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (x) {
  <span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};
}
</code></pre>
            <h3 id="exceptions">Exceptions</h3>
            <p>Yes</p>
            <p>You basically can&#39;t avoid exceptions if you&#39;re doing something non-trivial (using an application development framework, etc.). Go for it.</p>
            <h3 id="custom-exceptions">Custom exceptions</h3>
            <p>Yes</p>
            <p>Without custom exceptions, returning error information from a function that also returns a value can be tricky, not to mention inelegant. Bad solutions include passing in a reference type to hold error information or always returning Objects with
                a potential error member. These basically amount to a primitive exception handling hack. Feel free to use custom exceptions when appropriate.</p>
            <h3 id="standards-features">Standards features</h3>
            <p>Always preferred over non-standards features</p>
            <p>For maximum portability and compatibility, always prefer standards features over non-standards features (e.g., <code>string.charAt(3)</code> over <code>string[3]</code> and element access with DOM functions instead of using an application-specific
                shorthand).</p>
            <h3 id="wrapper-objects-for-primitive-types">Wrapper objects for primitive types</h3>
            <p>No</p>
            <p>There&#39;s no reason to use wrapper objects for primitive types, plus they&#39;re dangerous:</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">if</span> (x) {
  alert(<span class="hljs-string">'hi'</span>);  <span class="hljs-comment">// Shows 'hi'.</span>
}
</code></pre>
            <p>Don&#39;t do it!</p>
            <p>However type casting is fine.</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">if</span> (x) {
  alert(<span class="hljs-string">'hi'</span>);  <span class="hljs-comment">// This will never be alerted.</span>
}
<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">'boolean'</span>;
<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) == <span class="hljs-string">'object'</span>;
</code></pre>
            <p>This is very useful for casting things to <code>number</code>, <code>string</code> and <code>boolean</code>.</p>
            <h3 id="multi-level-prototype-hierarchies">Multi-level prototype hierarchies</h3>
            <p>Not preferred</p>
            <p>Multi-level prototype hierarchies are how JavaScript implements inheritance. You have a multi-level hierarchy if you have a user-defined class D with another user-defined class B as its prototype. These hierarchies are much harder to get right than
                they first appear!</p>
            <p>For that reason, it is best to use <code>goog.inherits()</code> from <a href="#">the Closure Library</a> or a similar library function.</p>
            <pre><code class="lang-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">D</span><span class="hljs-params">()</span> </span>{
  goog.base(<span class="hljs-keyword">this</span>)
}
goog.inherits(D, B);

D.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  ...
};
</code></pre>
            <h3 id="method-and-property-definitions">Method and property definitions</h3>
            <p><code>/** @constructor */ function SomeConstructor() { this.someProperty = 1; } Foo.prototype.someMethod = function() { ... };</code></p>
            <p>While there are several ways to attach methods and properties to an object created via &quot;new&quot;, the preferred style for methods is:</p>
            <pre><code class="lang-javascript">Foo.prototype.bar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">/* ... */</span>
};
</code></pre>
            <p>The preferred style for other properties is to initialize the field in the constructor:</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">/** @constructor */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">this</span>.bar = value;
}
</code></pre>
            <h5 id="why-">Why?</h5>
            <p>Current JavaScript engines optimize based on the &quot;shape&quot; of an object, <a href="#">adding a property to an object (including overriding a value set on the prototype) changes the shape and can degrade performance.</a></p>
            <h3 id="delete">delete</h3>
            <p>Prefer <code>this.foo = null</code>.</p>
            <pre><code class="lang-javascript"> Foo.prototype.dispose = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">this</span>.property_ = <span class="hljs-literal">null</span>;
};
</code></pre>
            <p>Instead of:</p>
            <pre><code class="lang-javascript">Foo.prototype.dispose = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.property_;
};
</code></pre>
            <p>In modern JavaScript engines, changing the number of properties on an object is much slower than reassigning the values. The delete keyword should be avoided except when it is necessary to remove a property from an object&#39;s iterated list of
                keys, or to change the result of <code>if (key in obj)</code>.</p>
            <h3 id="closures">Closures</h3>
            <p>Yes, but be careful.</p>
            <p>The ability to create closures is perhaps the most useful and often overlooked feature of JS. Here is <a href="#">a good description of how closures work</a>.</p>
            <p>One thing to keep in mind, however, is that a closure keeps a pointer to its enclosing scope. As a result, attaching a closure to a DOM element can create a circular reference and thus, a memory leak. For example, in the following code:</p>
            <pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(element, a, b)</span> </span>{
  element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* uses a and b */</span> };
}
</code></pre>
            <p>the function closure keeps a reference to <code>element</code>, <code>a</code>, and <code>b</code> even if it never uses <code>element</code>. Since <code>element</code> also keeps a reference to the closure, we have a cycle that won&#39;t be cleaned
                up by garbage collection. In these situations, the code can be structured as follows:</p>
            <pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(element, a, b)</span> </span>{
  element.onclick = bar(a, b);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">(a, b)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* uses a and b */</span> };
}
</code></pre>
            <h3 id="eval-">eval()</h3>
            <p>Only for code loaders and REPL (Readâ€“evalâ€“print loop)</p>
            <p><code>eval()</code> makes for confusing semantics and is dangerous to use if the string being <code>eval()</code>&#39;d contains user input. There&#39;s usually a better, clearer, and safer way to write your code, so its use is generally not permitted.</p>
            <p>For RPC you can always use JSON and read the result using <code>JSON.parse()</code> instead of <code>eval()</code>.</p>
            <p>Let&#39;s assume we have a server that returns something like this:</p>
            <pre><code class="lang-javascript">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Alice"</span>,
  <span class="hljs-attr">"id"</span>: <span class="hljs-number">31502</span>,
  <span class="hljs-attr">"email"</span>: <span class="hljs-string">"looking_glass@example.com"</span>
}
</code></pre>
            <pre><code class="lang-javascript"><span class="hljs-attribute">var userInfo</span> = eval(feed);
<span class="hljs-attribute">var email</span> = userInfo[<span class="hljs-string">'email'</span>];
</code></pre>
            <p>If the feed was modified to include malicious JavaScript code, then if we use <code>eval</code> then that code will be executed.</p>
            <pre><code class="lang-javascript"><span class="hljs-attribute">var userInfo</span> = JSON.parse(feed);
<span class="hljs-attribute">var email</span> = userInfo[<span class="hljs-string">'email'</span>];
</code></pre>
            <p>With <code>JSON.parse</code>, invalid JSON (including all executable JavaScript) will cause an exception to be thrown.</p>
            <h3 id="with-">with() {}</h3>
            <p>No</p>
            <p>Using <code>with</code> clouds the semantics of your program. Because the object of the <code>with</code> can have properties that collide with local variables, it can drastically change the meaning of your program. For example, what does this do?</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">with</span> (foo) {
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">return</span> x;
}
</code></pre>
            <p>Answer: anything. The local variable <code>x</code> could be clobbered by a property of <code>foo</code> and perhaps it even has a setter, in which case assigning <code>3</code> could cause lots of other code to execute. Don&#39;t use <code>with</code>.</p>
            <h3 id="this">this</h3>
            <p>Only in object constructors, methods, and in setting up closures</p>
            <p>The semantics of <code>this</code> can be tricky. At times it refers to the global object (in most places), the scope of the caller (in <code>eval</code>), a node in the DOM tree (when attached using an event handler HTML attribute), a newly created
                object (in a constructor), or some other object (if function was <code>call()</code>ed or <code>apply()</code>ed).</p>
            <p>Because this is so easy to get wrong, limit its use to those places where it is required:</p>
            <ul>
                <li>in constructors</li>
                <li>in methods of objects (including in the creation of closures)</li>
            </ul>
            <h3 id="for-in-loop">for-in loop</h3>
            <p>Only for iterating over keys in an object/map/hash</p>
            <p><code>for-in</code> loops are often incorrectly used to loop over the elements in an <code>Array</code>. This is however very error prone because it does not loop from <code>0</code> to <code>length - 1</code> but over all the present keys in the
                object and its prototype chain. Here are a few cases where it fails:</p>
            <pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArray</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> arr) {
    print(arr[key]);
  }
}

printArray([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);  <span class="hljs-comment">// This works.</span>

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>);
printArray(a);  <span class="hljs-comment">// This is wrong.</span>

a = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'*'</span>);
printArray(a);  <span class="hljs-comment">// This is wrong.</span>

a = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
a.buhu = <span class="hljs-string">'wine'</span>;
printArray(a);  <span class="hljs-comment">// This is wrong again.</span>

a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>;
a[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;
printArray(a);  <span class="hljs-comment">// This is wrong again.</span>
</code></pre>
            <p>Always use normal for loops when using arrays.</p>
            <pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArray</span><span class="hljs-params">(arr)</span> {</span>
  var l = arr.<span class="hljs-built_in">length</span>;
  <span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; l; <span class="hljs-built_in">i</span>++) {
    print(arr[i]);
  }
}
</code></pre>
            <h3 id="associative-arrays">Associative Arrays</h3>
            <p>Never use <code>Array</code> as a map/hash/associative array Associative <code>Array</code>s are not allowed... or more precisely you are not allowed to use non number indexes for arrays. If you need a map/hash use <code>Object</code> instead of
                <code>Array</code> in these cases because the features that you want are actually features of <code>Object</code> and not of <code>Array</code>. Array just happens to extend <code>Object</code> (like any other object in JS and therefore you
                might as well have used <code>Date</code>, <code>RegExp</code> or <code>String</code>).</p>
            <h3 id="multiline-string-literals">Multiline string literals</h3>
            <p>No</p>
            <p>Do not do this:</p>
            <pre><code class="lang-javascript">var myString = 'A rather long <span class="hljs-built_in">string</span> <span class="hljs-keyword">of</span> English <span class="hljs-built_in">text</span>, an <span class="hljs-keyword">error</span> message \
                actually <span class="hljs-keyword">that</span> just keeps going <span class="hljs-keyword">and</span> going <span class="hljs-comment">-- an error \</span>
                message <span class="hljs-keyword">to</span> make <span class="hljs-keyword">the</span> Energizer bunny blush (right <span class="hljs-keyword">through</span> \
                those Schwarzenegger shades)! Where was I? Oh yes, \
                you\'ve got an <span class="hljs-keyword">error</span> <span class="hljs-keyword">and</span> all <span class="hljs-keyword">the</span> extraneous whitespace <span class="hljs-keyword">is</span> \
                just gravy.  Have a nice <span class="hljs-built_in">day</span>.';
</code></pre>
            <p>The whitespace at the beginning of each line can&#39;t be safely stripped at compile time; whitespace after the slash will result in tricky errors.</p>
            <p>Use string concatenation instead:</p>
            <pre><code class="lang-javascript">var myString = <span class="hljs-comment">'A rather long string of English text, an error message ' +</span>
    <span class="hljs-comment">'actually that just keeps going and going -- an error ' +</span>
    <span class="hljs-comment">'message to make the Energizer bunny blush (right through ' +</span>
    <span class="hljs-comment">'those Schwarzenegger shades)! Where was I? Oh yes, ' +</span>
    <span class="hljs-comment">'you\'ve got an error and all the extraneous whitespace is ' +</span>
    <span class="hljs-comment">'just gravy.  Have a nice day.';</span>
</code></pre>
            <h3 id="array-and-object-literals">Array and Object literals</h3>
            <p>Yes</p>
            <p>Use <code>Array</code> and <code>Object</code> literals instead of <code>Array</code> and <code>Object</code> constructors.</p>
            <p>Array constructors are error-prone due to their arguments.</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">// Length is 3.</span>
<span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(x1, x2, x3);

<span class="hljs-comment">// Length is 2.</span>
<span class="hljs-keyword">var</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(x1, x2);

<span class="hljs-comment">// If x1 is a number and it is a natural number the length will be x1.</span>
<span class="hljs-comment">// If x1 is a number but not a natural number this will throw an exception.</span>
<span class="hljs-comment">// Otherwise the array will have one element with x1 as its value.</span>
<span class="hljs-keyword">var</span> a3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(x1);

<span class="hljs-comment">// Length is 0.</span>
<span class="hljs-keyword">var</span> a4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
</code></pre>
            <p>Because of this, if someone changes the code to pass 1 argument instead of 2 arguments, the array might not have the expected length.</p>
            <p>To avoid these kinds of weird cases, always use the more readable array literal.</p>
            <pre><code class="lang-javascript">var a = [x1, x2, x3]<span class="hljs-comment">;</span>
var <span class="hljs-built_in">a2</span> = [x1, x2]<span class="hljs-comment">;</span>
var <span class="hljs-built_in">a3</span> = [x1]<span class="hljs-comment">;</span>
var <span class="hljs-built_in">a4</span> = []<span class="hljs-comment">;</span>
</code></pre>
            <p>Object constructors don&#39;t have the same problems, but for readability and consistency object literals should be used.</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();

<span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
o2.a = <span class="hljs-number">0</span>;
o2.b = <span class="hljs-number">1</span>;
o2.c = <span class="hljs-number">2</span>;
o2[<span class="hljs-string">'strange key'</span>] = <span class="hljs-number">3</span>;
</code></pre>
            <p>Should be written as:</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">var</span> o = {};

<span class="hljs-keyword">var</span> o2 = {
  a: <span class="hljs-number">0</span>,
  b: <span class="hljs-number">1</span>,
  c: <span class="hljs-number">2</span>,
  <span class="hljs-string">'strange key'</span>: <span class="hljs-number">3</span>
};
</code></pre>
            <h3 id="modifying-prototypes-of-builtin-objects">Modifying prototypes of builtin objects</h3>
            <p>No</p>
            <p>Modifying builtins like <code>Object.prototype</code> and <code>Array.prototype</code> are strictly forbidden. Modifying other builtins like <code>Function.prototype</code> is less dangerous but still leads to hard to debug issues in production
                and should be avoided.</p>
            <h3 id="internet-explorer-s-conditional-comments">Internet Explorer&#39;s Conditional Comments</h3>
            <p>No</p>
            <p>Don&#39;t do this:</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">/*<span class="hljs-doctag">@cc</span>_on if (@_jscript) { return 2* @*/</span>  <span class="hljs-number">3</span>; <span class="hljs-comment">/*@ } @*/</span>
};
</code></pre>
            <p>Conditional Comments hinder automated tools as they can vary the JavaScript syntax tree at runtime.</p>
            <h2 id="javascript-style-rules">JavaScript Style Rules</h2>
            <h3 id="naming">Naming</h3>
            <p>In general, use <code>functionNamesLikeThis</code>, <code>variableNamesLikeThis</code>, <code>ClassNamesLikeThis</code>, <code>EnumNamesLikeThis</code>, <code>methodNamesLikeThis</code>, <code>CONSTANT_VALUES_LIKE_THIS</code>, <code>foo.namespaceNamesLikeThis.bar</code>,
                and <code>filenameslikethis.js</code>.</p>
            <h5 id="properties-and-methods">Properties and methods</h5>
            <ul>
                <li><em>Private</em> properties and methods should be named with a trailing underscore.</li>
                <li><em>Protected</em> properties and methods should be named without a trailing underscore (like public ones).</li>
            </ul>
            <p>For more information on <em>private</em> and <em>protected</em>, read the section on <a href="#">visibility</a>.</p>
            <h5 id="method-and-function-parameter">Method and function parameter</h5>
            <p>Optional function arguments start with <code>opt_</code>.</p>
            <p>Functions that take a variable number of arguments should have the last argument named <code>var_args</code>. You may not refer to <code>var_args</code> in the code; use the <code>arguments</code> array.</p>
            <p>Optional and variable arguments can also be specified in <code>@param</code> annotations. Although either convention is acceptable to the compiler, using both together is preferred.</p>
            <h5 id="getters-and-setters">Getters and Setters</h5>
            <p>EcmaScript 5 getters and setters for properties are discouraged. However, if they are used, then getters must not change observable state.</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">/**
 * WRONG -- Do NOT do this.
 */</span>
<span class="hljs-keyword">var</span> foo = { <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">next</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nextId++; } };
</code></pre>
            <h5 id="accessor-functions">Accessor functions</h5>
            <p>Getters and setters methods for properties are not required. However, if they are used, then getters must be named <code>getFoo()</code> and setters must be named <code>setFoo(value)</code>. (For boolean getters, <code>isFoo()</code> is also acceptable,
                and often sounds more natural.)</p>
            <h5 id="namespaces">Namespaces</h5>
            <p>JavaScript has no inherent packaging or namespacing support.</p>
            <p>Global name conflicts are difficult to debug, and can cause intractable problems when two projects try to integrate. In order to make it possible to share common JavaScript code, we&#39;ve adopted conventions to prevent collisions.</p>
            <h6 id="use-namespaces-for-global-code">Use namespaces for global code</h6>
            <p>ALWAYS prefix identifiers in the global scope with a unique pseudo namespace related to the project or library. If you are working on &quot;Project Sloth&quot;, a reasonable pseudo namespace would be <code>sloth.*</code>.</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">var</span> sloth = {};

sloth.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  ...
};
</code></pre>
            <p>Many JavaScript libraries, including <a href="#">the Closure Library</a> and <a href="#">Dojo toolkit</a> give you high-level functions for declaring your namespaces. Be consistent about how you declare your namespaces.</p>
            <pre><code class="lang-javascript">goog.provide(<span class="hljs-string">'sloth'</span>);

sloth.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  ...
};
</code></pre>
            <h6 id="respect-namespace-ownership">Respect namespace ownership</h6>
            <p>When choosing a child-namespace, make sure that the owners of the parent namespace know what you are doing. If you start a project that creates hats for sloths, make sure that the Sloth team knows that you&#39;re using <code>sloth.hats</code>.</p>
            <h6 id="use-different-namespaces-for-external-code-and-internal-code">Use different namespaces for external code and internal code</h6>
            <p>&quot;External code&quot; is code that comes from outside your codebase, and is compiled independently. Internal and external names should be kept strictly separate. If you&#39;re using an external library that makes things available in <code>foo.hats.*</code>,
                your internal code should not define all its symbols in <code>foo.hats.*</code>, because it will break if the other team defines new symbols.</p>
            <pre><code class="lang-javascript">foo.<span class="hljs-keyword">require</span>(<span class="hljs-string">'foo.hats'</span>);

<span class="hljs-comment">/**
 * WRONG -- Do NOT do this.
 * <span class="hljs-doctag">@constructor</span>
 * <span class="hljs-doctag">@extends</span> {foo.hats.RoundHat}
 */</span>
foo.hats.BowlerHat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
};
</code></pre>
            <p>If you need to define new APIs on an external namespace, then you should explicitly export the public API functions, and only those functions. Your internal code should call the internal APIs by their internal names, for consistency and so that
                the compiler can optimize them better.</p>
            <pre><code class="lang-javascript">foo.provide(<span class="hljs-string">'googleyhats.BowlerHat'</span>);

foo.<span class="hljs-keyword">require</span>(<span class="hljs-string">'foo.hats'</span>);

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@constructor</span>
 * <span class="hljs-doctag">@extends</span> {foo.hats.RoundHat}
 */</span>
googleyhats.BowlerHat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  ...
};

goog.exportSymbol(<span class="hljs-string">'foo.hats.BowlerHat'</span>, googleyhats.BowlerHat);
</code></pre>
            <h6 id="alias-long-type-names-to-improve-readability">Alias long type names to improve readability</h6>
            <p>Use local aliases for fully-qualified types if doing so improves readability. The name of a local alias should match the last part of the type.</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@constructor</span>
 */</span>
some.<span class="hljs-keyword">long</span>.namespace.MyClass = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
};

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {some.long.namespace.MyClass} a
 */</span>
some.<span class="hljs-keyword">long</span>.namespace.MyClass.staticHelper = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span> </span>{
  ...
};

myapp.main = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> MyClass = some.<span class="hljs-keyword">long</span>.namespace.MyClass;
  <span class="hljs-keyword">var</span> staticHelper = some.<span class="hljs-keyword">long</span>.namespace.MyClass.staticHelper;
  staticHelper(<span class="hljs-keyword">new</span> MyClass());
};
</code></pre>
            <p>Do not create local aliases of namespaces. Namespaces should only be aliased using <a href="#">goog.scope</a>.</p>
            <pre><code class="lang-javascript">myapp.main = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> <span class="hljs-keyword">namespace</span> = some.long.namespace;
  <span class="hljs-keyword">namespace</span>.MyClass.staticHelper(<span class="hljs-keyword">new</span> <span class="hljs-keyword">namespace</span>.MyClass());
};
</code></pre>
            <p>Avoid accessing properties of an aliased type, unless it is an enum.</p>
            <pre><code class="lang-javascript">/** @<span class="hljs-class"><span class="hljs-keyword">enum</span> {<span class="hljs-title">string</span>} */</span>
some.long.namespace.Fruit = {
  <span class="hljs-symbol">APPLE:</span> <span class="hljs-string">'a'</span>,
  <span class="hljs-symbol">BANANA:</span> <span class="hljs-string">'b'</span>
};

myapp.main = function() {
  var Fruit = some.long.namespace.Fruit;
  switch (fruit) {
    <span class="hljs-keyword">case</span> Fruit.<span class="hljs-symbol">APPLE:</span>
      ...
    <span class="hljs-keyword">case</span> Fruit.<span class="hljs-symbol">BANANA:</span>
      ...
  }
};
</code></pre>
            <pre><code class="lang-javascript">myapp.main = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> MyClass = some.<span class="hljs-keyword">long</span>.namespace.MyClass;
  MyClass.staticHelper(<span class="hljs-keyword">null</span>);
};
</code></pre>
            <p>Never create aliases in the global scope. Use them only in function blocks.</p>
            <h5 id="filenames">Filenames</h5>
            <p>Filenames should be all lowercase in order to avoid confusion on case-sensitive platforms. Filenames should end in .js, and should contain no punctuation except for - or <em> (prefer - to </em>).</p>
            <h3 id="custom-tostring-methods">Custom toString() methods</h3>
            <p>Must always succeed without side effects. You can control how your objects string-ify themselves by defining a custom <code>toString()</code> method. This is fine, but you need to ensure that your method (1) always succeeds and (2) does not have
                side-effects. If your method doesn&#39;t meet these criteria, it&#39;s very easy to run into serious problems. For example, if <code>toString()</code> calls a method that does an <code>assert</code>, <code>assert</code> might try to output the
                name of the object in which it failed, which of course requires calling <code>toString()</code>.</p>
            <h3 id="deferred-initialization">Deferred initialization</h3>
            <p>OK</p>
            <p>It isn&#39;t always possible to initialize variables at the point of declaration, so deferred initialization is fine.</p>
            <h3 id="explicit-scope">Explicit scope</h3>
            <p>Always</p>
            <p>Always use explicit scope - doing so increases portability and clarity. For example, don&#39;t rely on <code>window</code> being in the scope chain. You might want to use your function in another application for which <code>window</code> is not
                the content window.</p>
            <h3 id="code-formatting">Code formatting</h3>
            <p>Expand for more information. We follow the <a href="#">C++ formatting rules</a> in spirit, with the following additional clarifications.</p>
            <h5 id="curly-braces">Curly Braces</h5>
            <p>Because of implicit semicolon insertion, always start your curly braces on the same line as whatever they&#39;re opening. For example:</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (something) {
  <span class="hljs-comment">// ...</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
            <h5 id="array-and-object-initializers">Array and Object Initializers</h5>
            <p>Single-line array and object initializers are allowed when they fit on a line:</p>
            <pre><code class="lang-javascript"><span class="hljs-built_in">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  // No <span class="hljs-built_in">space</span> after [ <span class="hljs-keyword">or</span> before ].
<span class="hljs-built_in">var</span> obj = {a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>};  // No <span class="hljs-built_in">space</span> after { <span class="hljs-keyword">or</span> before }.
</code></pre>
            <p>Multiline array initializers and object initializers are indented 2 spaces, with the braces on their own line, just like blocks.</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">// Object initializer.</span>
<span class="hljs-keyword">var</span> inset = {
  top: <span class="hljs-number">10</span>,
  right: <span class="hljs-number">20</span>,
  bottom: <span class="hljs-number">15</span>,
  left: <span class="hljs-number">12</span>
};

<span class="hljs-comment">// Array initializer.</span>
<span class="hljs-keyword">this</span>.rows_ = [
  '<span class="hljs-string">"Slartibartfast"</span> &lt;fjordmaster<span class="hljs-meta">@magrathea</span>.com&gt;',
  '<span class="hljs-string">"Zaphod Beeblebrox"</span> &lt;theprez<span class="hljs-meta">@universe</span>.gov&gt;',
  '<span class="hljs-string">"Ford Prefect"</span> &lt;ford<span class="hljs-meta">@theguide</span>.com&gt;',
  '<span class="hljs-string">"Arthur Dent"</span> &lt;has.no.tea<span class="hljs-meta">@gmail</span>.com&gt;',
  '<span class="hljs-string">"Marvin the Paranoid Android"</span> &lt;marv<span class="hljs-meta">@googlemail</span>.com&gt;',
  <span class="hljs-symbol">'the</span>.mice<span class="hljs-meta">@magrathea</span>.com'
];

<span class="hljs-comment">// Used in a method call.</span>
goog.dom.createDom(goog.dom.<span class="hljs-type">TagName</span>.<span class="hljs-type">DIV</span>, {
  id: <span class="hljs-symbol">'fo</span>o',
  className: <span class="hljs-symbol">'some</span>-css-<span class="hljs-class"><span class="hljs-keyword">class</span>',</span>
  style: <span class="hljs-symbol">'display</span>:none'
}, <span class="hljs-symbol">'Hello</span>, world!');
</code></pre>
            <p>Long identifiers or values present problems for aligned initialization lists, so always prefer non-aligned initialization. For example:</p>
            <pre><code class="lang-javascript">CORRECT_Object.prototype = {
<span class="hljs-symbol">  a:</span> <span class="hljs-number">0</span>,
<span class="hljs-symbol">  b:</span> <span class="hljs-number">1</span>,
<span class="hljs-symbol">  lengthyName:</span> <span class="hljs-number">2</span>
};
</code></pre>
            <p>Not like this:</p>
            <pre><code class="lang-javascript"><span class="hljs-type">WRONG_Object</span>.proto<span class="hljs-keyword">type</span> = {
  a          : 0,
  b          : 1,
  lengthyName: 2
};
</code></pre>
            <h5 id="function-arguments">Function Arguments</h5>
            <p>When possible, all function arguments should be listed on the same line. If doing so would exceed the 80-column limit, the arguments must be line-wrapped in a readable way. To save space, you may wrap as close to 80 as possible, or put each argument
                on its own line to enhance readability. The indentation may be either four spaces, or aligned to the parenthesis. Below are the most common patterns for argument wrapping:</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">// Four-space, wrap at 80.  Works with very long function names, survives</span>
<span class="hljs-comment">// renaming without reindenting, low on space.</span>
goog.foo.bar.doThingThatIsVeryDifficultToExplain = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(
    veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator)</span> </span>{
  <span class="hljs-comment">// ...</span>
};

<span class="hljs-comment">// Four-space, one argument per line.  Works with long function names,</span>
<span class="hljs-comment">// survives renaming, and emphasizes each argument.</span>
goog.foo.bar.doThingThatIsVeryDifficultToExplain = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator)</span> </span>{
  <span class="hljs-comment">// ...</span>
};

<span class="hljs-comment">// Parenthesis-aligned indentation, wrap at 80.  Visually groups arguments,</span>
<span class="hljs-comment">// low on space.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
             tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator)</span> </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// Parenthesis-aligned, one argument per line.  Emphasizes each</span>
<span class="hljs-comment">// individual argument.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span><span class="hljs-params">(veryDescriptiveArgumentNumberOne,
             veryDescriptiveArgumentTwo,
             tableModelEventHandlerProxy,
             artichokeDescriptorAdapterIterator)</span> </span>{
  <span class="hljs-comment">// ...</span>
}
</code></pre>
            <p>When the function call is itself indented, you&#39;re free to start the 4-space indent relative to the beginning of the original statement or relative to the beginning of the current function call. The following are all acceptable indentation styles.</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (veryLongFunctionNameA(
        veryLongArgumentName) |<span class="hljs-type">|
    veryLongFunctionNameB</span>(
    veryLongArgumentName)) {
  veryLongFunctionNameC(veryLongFunctionNameD(
      veryLongFunctioNameE(
          veryLongFunctionNameF)));
}
</code></pre>
            <h5 id="passing-anonymous-functions">Passing Anonymous Functions</h5>
            <p>When declaring an anonymous function in the list of arguments for a function call, the body of the function is indented two spaces from the left edge of the statement, or two spaces from the left edge of the function keyword. This is to make the
                body of the anonymous function easier to read (i.e. not be all squished up into the right half of the screen).</p>
            <pre><code class="lang-javascript"><span class="hljs-symbol">prefix.something.reallyLongFunctionName</span>(<span class="hljs-string">'whatever'</span>, <span class="hljs-meta">function</span>(<span class="hljs-built_in">a1</span>, <span class="hljs-built_in">a2</span>) {
  <span class="hljs-meta">if</span> (<span class="hljs-built_in">a1</span>.equals(<span class="hljs-built_in">a2</span>)) {
    someOtherLongFunctionName(<span class="hljs-built_in">a1</span>)<span class="hljs-comment">;</span>
  } <span class="hljs-meta">else</span> {
    <span class="hljs-keyword">andNowForSomethingCompletelyDifferent(a2.parrot);
</span>  }
})<span class="hljs-comment">;</span>

<span class="hljs-symbol">var</span> names = prefix.something.myExcellentMapFunction(
    verboselyNamedCollectionOfItems,
    <span class="hljs-meta">function</span>(<span class="hljs-keyword">item) </span>{
      return <span class="hljs-keyword">item.name;
</span>    })<span class="hljs-comment">;</span>
</code></pre>
            <h5 id="aliasing-with-goog-scope">Aliasing with goog.scope</h5>
            <p><a href="#"><code>goog.scope</code></a> may be used to shorten references to namespaced symbols in programs using <a href="#">the Closure Library</a>.</p>
            <p>Only one <code>goog.scope</code> invocation may be added per file. Always place it in the global scope.</p>
            <p>The opening <code>goog.scope(function() {</code> invocation must be preceded by exactly one blank line and follow any <code>goog.provide</code> statements, <code>goog.require</code> statements, or top-level comments. The invocation must be closed
                on the last line in the file. Append <code>// goog.scope</code> to the closing statement of the scope. Separate the comment from the semicolon by two spaces.</p>
            <p>Similar to C++ namespaces, do not indent under goog.scope declarations. Instead, continue from the 0 column.</p>
            <p>Only alias names that will not be re-assigned to another object (e.g., most constructors, enums, and namespaces). Do not do this (see below for how to alias a constructor):</p>
            <pre><code class="lang-javascript">goog.scope(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">var</span> Button = goog.ui.Button;

Button = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ ... };
...
</code></pre>
            <p>Names must be the same as the last property of the global that they are aliasing.</p>
            <pre><code class="lang-javascript">goog.provide(<span class="hljs-string">'my.module.SomeType'</span>);

goog.<span class="hljs-keyword">require</span>(<span class="hljs-string">'goog.dom'</span>);
goog.<span class="hljs-keyword">require</span>(<span class="hljs-string">'goog.ui.Button'</span>);

goog.scope(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">var</span> Button = goog.ui.Button;
<span class="hljs-keyword">var</span> dom = goog.dom;

<span class="hljs-comment">// Alias new types after the constructor declaration.</span>
my.module.SomeType = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ ... };
<span class="hljs-keyword">var</span> SomeType = my.module.SomeType;

<span class="hljs-comment">// Declare methods on the prototype as usual:</span>
SomeType.prototype.findButton = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Button as aliased above.</span>
  this.button = <span class="hljs-keyword">new</span> Button(dom.getElement(<span class="hljs-string">'my-button'</span>));
};
...
});  <span class="hljs-comment">// goog.scope</span>
</code></pre>
            <h5 id="indenting-wrapped-lines">Indenting wrapped lines</h5>
            <p>Except for <a href="#">array literals, object literals</a>, and anonymous functions, all wrapped lines should be indented either left-aligned to a sibling expression above, or four spaces (not two spaces) deeper than a parent expression (where &quot;sibling&quot;
                and &quot;parent&quot; refer to parenthesis nesting level).</p>
            <pre><code class="lang-javascript">someWonderfulHtml = <span class="hljs-string">''</span> +
                    getEvenMoreHtml(someReallyInterestingValues, moreValues,
                                    evenMoreParams, <span class="hljs-string">'a duck'</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">72</span>,
                                    slightlyMoreMonkeys(<span class="hljs-number">0xfff</span>)) +
                    <span class="hljs-string">''</span>;

thisIsAVeryLongVariableName =
    hereIsAnEvenLongerOtherFunctionNameThatWillNotFitOnPrevLine();

thisIsAVeryLongVariableName = siblingOne + siblingTwo + siblingThree +
    siblingFour + siblingFive + siblingSix + siblingSeven +
    moreSiblingExpressions + allAtTheSameIndentationLevel;

thisIsAVeryLongVariableName = operandOne + operandTwo + operandThree +
    operandFour + operandFive * (
        aNestedChildExpression + shouldBeIndentedMore);

someValue = <span class="hljs-keyword">this</span>.foo(
    shortArg,
    <span class="hljs-string">'Some really long string arg - this is a pretty common case, actually.'</span>,
    shorty2,
    <span class="hljs-keyword">this</span>.bar());

<span class="hljs-keyword">if</span> (searchableCollection(allYourStuff).contains(theStuffYouWant) &amp;&amp;
    !ambientNotification.isActive() &amp;&amp; (<span class="hljs-keyword">client</span>.isAmbientSupported() ||
                                        <span class="hljs-keyword">client</span>.alwaysTryAmbientAnyways())) {
  ambientNotification.activate();
}
</code></pre>
            <p>Blank lines</p>
            <p>Use newlines to group logically related pieces of code. For example:</p>
            <pre><code class="lang-javascript">doSomethingTo(<span class="hljs-name">x</span>)<span class="hljs-comment">;</span>
doSomethingElseTo(<span class="hljs-name">x</span>)<span class="hljs-comment">;</span>
andThen(<span class="hljs-name">x</span>)<span class="hljs-comment">;</span>

nowDoSomethingWith(<span class="hljs-name">y</span>)<span class="hljs-comment">;</span>

andNowWith(<span class="hljs-name">z</span>)<span class="hljs-comment">;</span>
</code></pre>
            <h5 id="binary-and-ternary-operators">Binary and Ternary Operators</h5>
            <p>Always put the operator on the preceding line. Otherwise, line breaks and indentation follow the same rules as in other Google style guides. This operator placement was initially agreed upon out of concerns about automatic semicolon insertion. In
                fact, semicolon insertion cannot happen before a binary operator, but new code should stick to this style for consistency.</p>
            <pre><code class="lang-javascript"><span class="hljs-keyword">var</span> x = a ? b : <span class="hljs-built_in">c</span>;  <span class="hljs-comment">// All on one line if it will fit.</span>

<span class="hljs-comment">// Indentation +4 is OK.</span>
<span class="hljs-keyword">var</span> y = a ?
    longButSimpleOperandB : longButSimpleOperandC;

<span class="hljs-comment">// Indenting to the line position of the first operand is also OK.</span>
<span class="hljs-keyword">var</span> z = a ?
        moreComplicatedB :
        moreComplicatedC;
<span class="hljs-type">This</span> includes the dot <span class="hljs-keyword">operator</span>.

<span class="hljs-keyword">var</span> x = foo.bar().
    doSomething().
    doSomethingElse();
</code></pre>
            <h3 id="parentheses">Parentheses</h3>
            <p>Only where required</p>
            <p>Use sparingly and in general only where required by the syntax and semantics.</p>
            <p>Never use parentheses for unary operators such as <code>delete</code>, <code>typeof</code> and <code>void</code> or after keywords such as <code>return</code>, <code>throw</code> as well as others (<code>case</code>, <code>in</code> or <code>new</code>).</p>
            <h3 id="strings">Strings</h3>
            <p>Prefer &#39; over &quot;</p>
            <p>For consistency single-quotes (&#39;) are preferred to double-quotes (&quot;). This is helpful when creating strings that include HTML:</p>
            <pre><code class="lang-javascript">var msg = <span class="hljs-symbol">'This</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">some</span> HTML';
</code></pre>
            <h3 id="visibility-private-and-protected-fields-">Visibility (private and protected fields)</h3>
            <p>Encouraged, use JSDoc annotations <code>@private</code> and <code>@protected</code></p>
            <p>We recommend the use of the JSDoc annotations <code>@private</code> and <code>@protected</code> to indicate visibility levels for classes, functions, and properties.</p>
            <p>The --jscomp_warning=visibility compiler flag turns on compiler warnings for visibility violations. See <a href="#">Closure Compiler Warnings</a>.</p>
            <p><code>@private</code> global variables and functions are only accessible to code in the same file.</p>
            <p>Constructors marked <code>@private</code> may only be instantiated by code in the same file and by their static and instance members. <code>@private</code> constructors may also be accessed anywhere in the same file for their public static properties
                and by the <code>instanceof</code> operator.</p>
            <p>Global variables, functions, and constructors should never be annotated <code>@protected</code>.</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">// File 1.</span>
<span class="hljs-comment">// AA_PrivateClass_ and AA_init_ are accessible because they are global</span>
<span class="hljs-comment">// and in the same file.</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@private</span>
 * <span class="hljs-doctag">@constructor</span>
 */</span>
AA_PrivateClass_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
};

<span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AA_init_</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AA_PrivateClass_();
}

AA_init_();
</code></pre>
            <p><code>@private</code> properties are accessible to all code in the same file, plus all static methods and instance methods of that class that &quot;owns&quot; the property, if the property belongs to a class. They cannot be accessed or overridden
                from a subclass in a different file.</p>
            <p><code>@protected</code> properties are accessible to all code in the same file, plus any static methods and instance methods of any subclass of a class that &quot;owns&quot; the property.</p>
            <p>Note that these semantics differ from those of C++ and Java, in that they grant private and protected access to all code in the same file, not just in the same class or class hierarchy. Also, unlike in C++, private properties cannot be overridden
                by a subclass.</p>
            <pre><code class="lang-javascript"><span class="hljs-comment">// File 1.</span>

<span class="hljs-comment">/** <span class="hljs-doctag">@constructor</span> */</span>
AA_PublicClass = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span>
  this.privateProp_ = <span class="hljs-number">2</span>;

  <span class="hljs-comment">/** <span class="hljs-doctag">@protected</span> */</span>
  this.protectedProp = <span class="hljs-number">4</span>;
};

<span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span>
AA_PublicClass.staticPrivateProp_ = <span class="hljs-number">1</span>;

<span class="hljs-comment">/** <span class="hljs-doctag">@protected</span> */</span>
AA_PublicClass.staticProtectedProp = <span class="hljs-number">31</span>;

<span class="hljs-comment">/** <span class="hljs-doctag">@private</span> */</span>
AA_PublicClass.prototype.privateMethod_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};

<span class="hljs-comment">/** <span class="hljs-doctag">@protected</span> */</span>
AA_PublicClass.prototype.protectedMethod = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{};

<span class="hljs-comment">// File 2.</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@return</span> {number} The number of ducks we've arranged in a row.
 */</span>
AA_PublicClass.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Legal accesses of these two properties.</span>
  <span class="hljs-keyword">return</span> this.privateProp_ + AA_PublicClass.staticPrivateProp_;
};

<span class="hljs-comment">// File 3.</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@constructor</span>
 * <span class="hljs-doctag">@extends</span> {AA_PublicClass}
 */</span>
AA_SubClass = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Legal access of a protected static property.</span>
  AA_PublicClass.staticProtectedProp = this.method();
};
goog.inherits(AA_SubClass, AA_PublicClass);

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@return</span> {number} The number of ducks we've arranged in a row.
 */</span>
AA_SubClass.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Legal access of a protected instance property.</span>
  <span class="hljs-keyword">return</span> this.protectedProp;
};
</code></pre>
            <p>Notice that in JavaScript, there is no distinction between a type (like <code>AA_PrivateClass_</code>) and the constructor for that type. There is no way to express both that a type is public and its constructor is private (because the constructor
                could easily be aliased in a way that would defeat the privacy check).</p>
            <h3 id="javascript-types">JavaScript Types</h3>
            <p>Encouraged and enforced by the compiler. When documenting a type in JSDoc, be as specific and accurate as possible. The types we support are based on the <a href="#">EcmaScript 4 spec</a>.</p>
            <h5 id="the-javascript-type-language">The JavaScript Type Language</h5>
            <p>The ES4 proposal contained a language for specifying JavaScript types. We use this language in JsDoc to express the types of function parameters and return values.</p>
            <p>As the ES4 proposal has evolved, this language has changed. The compiler still supports old syntaxes for types, but those syntaxes are deprecated.</p>
            <table>
                <thead>
                    <tr>
                        <th>Syntax Name</th>
                        <th>Syntax</th>
                        <th>Description</th>
                        <th>Deprecated Syntaxes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Primitive Type</td>
                        <td>There are 5 primitive types in JavaScript: <code>{null}</code>, <code>{undefined}</code>, <code>{boolean}</code>, <code>{number}</code>, and <code>{string}</code>.</td>
                        <td>Simply the name of a type.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Instance Type</td>
                        <td>
                            <code>{Object}</code><br>An instance of Object or null.
                            <br>
                            <br>
                            <code>{Function}</code><br>An instance of Function or null.
                            <br>
                            <br>
                            <code>{EventTarget}</code><br>An instance of a constructor that implements the EventTarget interface, or null.
                        </td>
                        <td>
                            An instance of a constructor or interface function.
                            <br>
                            <br> Constructor functions are functions defined with the <code>@constructor</code> JSDoc tag. Interface functions are functions defined with the <code>@interface</code> JSDoc tag.
                            <br>
                            <br> By default, instance types will accept null. This is the only type syntax that makes the type nullable. Other type syntaxes in this table will not accept null.
                        </td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Enum Type</td>
                        <td>
                            <code>{goog.events.EventType}</code><br>One of the properties of the object literal initializer of <code>goog.events.EventType</code>.
                        </td>
                        <td>
                            An enum must be initialized as an object literal, or as an alias of another enum, annotated with the <code>@enum</code> JSDoc tag. The properties of this literal are the instances of the enum. The syntax of the enum is defined
                            <a
                                href="#">below</a>.
                                <br>
                                <br> Note that this is one of the few things in our type system that were not in the ES4 spec.
                        </td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Type Application</td>
                        <td>
                            <code>{Array.&lt;string&gt;}</code><br>An array of strings.
                            <br>
                            <br>
                            <code>{Object.&lt;string, number&gt;}</code> An object in which the keys are strings and the values are numbers.
                        </td>
                        <td>Parameterizes a type, by applying a set of type arguments to that type. The idea is analogous to generics in Java.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Type Union</td>
                        <td>
                            <code>{(number|boolean)}</code><br>A number or a boolean.
                        </td>
                        <td>
                            Indicates that a value might have type A OR type B.
                            <br>
                            <br> The parentheses may be omitted at the top-level expression, but the parentheses should be included in sub-expressions to avoid ambiguity.<br><code>{number|boolean}</code><br><code>{function(): (number|boolean)}</code>
                        </td>
                        <td>
                            <code>{(number,boolean)}</code>,<br><code>{(number||boolean)}</code>
                        </td>
                    </tr>
                    <tr>
                        <td>Nullable type</td>
                        <td>
                            {?number}<br>A number or null.
                        </td>
                        <td>Shorthand for the union of the null type with any other type. This is just syntactic sugar.</td>
                        <td><code>{number?}</code></td>
                    </tr>
                    <tr>
                        <td>Non-nullable type</td>
                        <td>
                            <code>{!Object}</code><br>An Object, but never the null value.
                        </td>
                        <td>Filters null out of nullable types. Most often used with instance types, which are nullable by default.</td>
                        <td><code>{Object!}</code></td>
                    </tr>
                    <tr>
                        <td>Record Type</td>
                        <td>
                            <code>{{myNum: number, myObject}}</code><br>An anonymous type with the given type members.
                        </td>
                        <td>
                            Indicates that the value has the specified members with the specified types. In this case, <code>myNum</code> with a type <code>number</code> and <code>myObject</code> with any type.
                            <br>
                            <br> Notice that the braces are part of the type syntax. For example, to denote an <code>Array</code> of objects that have a <code>length</code> property, you might write <code>Array.&lt;{length}&gt;</code>.
                        </td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Function Type</td>
                        <td>
                            <code>{function(string, boolean)}</code><br>A function that takes two arguments (a string and a boolean), and has an unknown return value.
                        </td>
                        <td>Specifies a function.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Function Return Type</td>
                        <td>
                            <code>{function(): number}</code><br>A function that takes no arguments and returns a number.
                        </td>
                        <td>Specifies a function return type.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Function <code>this</code> Type</td>
                        <td>
                            <code>{function(this:goog.ui.Menu, string)}</code><br>A function that takes one argument (a string), and executes in the context of a goog.ui.Menu.
                        </td>
                        <td>Specifies the context type of a function type.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>Function <code>new</code> Type</td>
                        <td>
                            <code>{function(new:goog.ui.Menu, string)}</code><br>A constructor that takes one argument (a string), and creates a new instance of goog.ui.Menu when called with the &#39;new&#39; keyword.
                        </td>
                        <td>Specifies the constructed type of a constructor.</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>

            <p>Variable arguments {function(string, ...[number]): number} A function that takes one argument (a string), and then a variable number of arguments that must be numbers. Specifies variable arguments to a function. Variable arguments (in @param annotations)
                @param {...number} var_args A variable number of arguments to an annotated function. Specifies that the annotated function accepts a variable number of arguments.<br>Function optional arguments {function(?string=, number=)} A function that takes
                one optional, nullable string and one optional number as arguments. The = syntax is only for function type declarations. Specifies optional arguments to a function. Function optional arguments (in @param annotations) @param {number=} opt_argument
                An optional parameter of type number. Specifies that the annotated function accepts an optional argument. The ALL type {*} Indicates that the variable can take on any type.<br>The UNKNOWN type {?} Indicates that the variable can take on any
                type, and the compiler should not type-check any uses of it.<br>Types in JavaScript</p>
            <p>Type Example Value Examples Description number
                <br>1 1.0 -5 1e5 Math.PI Number
                <br>new Number(true) Number object string
                <br>&#39;Hello&#39; &quot;World&quot; String(42) String value String
                <br>new String(&#39;Hello&#39;) new String(42) String object boolean true false Boolean(0) Boolean value Boolean new Boolean(true) Boolean object RegExp
                <br>new RegExp(&#39;hello&#39;) /world/g Date
                <br>new Date new Date() null
                <br>null undefined
                <br>undefined void
                <br>function f() { return; } No return value Array
                <br>[&#39;foo&#39;, 0.3, null] [] Untyped Array Array.
                <number><br>[11, 22, 33] An Array of numbers Array.
                    <Array.<string>&gt;<br>[[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [&#39;foo&#39;, &#39;bar&#39;]] Array of Arrays of strings Object
                        <br>{} {foo: &#39;abc&#39;, bar: 123, baz: null} Object.
                        <string>
                            {&#39;foo&#39;: &#39;bar&#39;} An Object in which the values are strings. Object.
                            <number, string>
                                var obj = {}; obj[1] = &#39;bar&#39;; An Object in which the keys are numbers and the values are strings. Note that in JavaScript, the keys are always implicitly converted to strings, so obj[&#39;1&#39;] == obj[1]. So the key will always be a string in for...in
                                loops. But the compiler will verify the type of the key when indexing into the object. Function
                                <br>function(x, y) { return x <em> y;
}
Function object
function(number, number): number<br>function(x, y) {
  return x </em> y; } function value SomeClass
                                <br>/<em>* @constructor </em>/ function SomeClass() {}</p>
            <p>new SomeClass(); SomeInterface
                <br>/<em>* @interface </em>/ function SomeInterface() {}</p>
            <p>SomeInterface.prototype.draw = function() {}; project.MyClass /
                <em>* @constructor </em>/ project.MyClass = function () {}</p>
            <p>new project.MyClass() project.MyEnum
                <br>/<strong> @enum {string} */
project.MyEnum = {
  /</strong> The color blue. <em>/
  BLUE: &#39;#0000dd&#39;,
  /** The color red. </em>/ RED: &#39;#dd0000&#39; }; Enumeration JSDoc comments on enum values are optional. Element document.createElement(&#39;div&#39;) Elements in the DOM. Node
                <br>document.body.firstChild Nodes in the DOM. HTMLInputElement
                <br>htmlDocument.getElementsByTagName(&#39;input&#39;)[0] A specific type of DOM element. Type Casts</p>
            <p>In cases where type-checking doesn&#39;t accurately infer the type of an expression, it is possible to add a type cast comment by adding a type annotation comment and enclosing the expression in parentheses. The parentheses are required.</p>
            <p>/<em>* @type {number} </em>/ (x) Nullable vs. Optional Parameters and Properties</p>
            <p>Because JavaScript is a loosely-typed language, it is very important to understand the subtle differences between optional, nullable, and undefined function parameters and class properties.</p>
            <p>Instances of classes and interfaces are nullable by default. For example, the following declaration</p>
            <p>/**</p>
            <ul>
                <li>Some class, initialized with a value.</li>
                <li>@param {Object} value Some value.</li>
                <li>@constructor
                    <em>/
function MyClass(value) {
/*</em>
                    <ul>
                        <li>Some value.</li>
                        <li>@type {Object}</li>
                        <li>@private */ this.myValue
                            <em> = value;
}
tells the compiler that the myValue</em> property holds either an Object or null. If myValue_ must never be null, it should be declared like this:</li>
                    </ul>
                </li>
            </ul>
            <p>/**</p>
            <ul>
                <li>Some class, initialized with a non-null value.</li>
                <li>@param {!Object} value Some value.</li>
                <li>@constructor
                    <em>/
function MyClass(value) {
/*</em>
                    <ul>
                        <li>Some value.</li>
                        <li>@type {!Object}</li>
                        <li>@private */ this.myValue_ = value; } This way, if the compiler can determine that somewhere in the code MyClass is initialized with a null value, it will issue a warning.</li>
                    </ul>
                </li>
            </ul>
            <p>Optional parameters to functions may be undefined at runtime, so if they are assigned to class properties, those properties must be declared accordingly:</p>
            <p>/**</p>
            <ul>
                <li>Some class, initialized with an optional value.</li>
                <li>@param {Object=} opt_value Some value (optional).</li>
                <li>@constructor
                    <em>/
function MyClass(opt_value) {
/*</em>
                    <ul>
                        <li>Some value.</li>
                        <li>@type {Object|undefined}</li>
                        <li>@private */ this.myValue_ = opt<em>value;
}
This tells the compiler that myValue</em> may hold an Object, null, or remain undefined.</li>
                    </ul>
                </li>
            </ul>
            <p>Note that the optional parameter opt_value is declared to be of type {Object=}, not {Object|undefined}. This is because optional parameters may, by definition, be undefined. While there is no harm in explicitly declaring an optional parameter as
                possibly undefined, it is both unnecessary and makes the code harder to read.</p>
            <p>Finally, note that being nullable and being optional are orthogonal properties. The following four declarations are all different:</p>
            <p>/**</p>
            <ul>
                <li>Takes four arguments, two of which are nullable, and two of which are</li>
                <li>optional.</li>
                <li>@param {!Object} nonNull Mandatory (must not be undefined), must not be null.</li>
                <li>@param {Object} mayBeNull Mandatory (must not be undefined), may be null.</li>
                <li>@param {!Object=} opt_nonNull Optional (may be undefined), but if present,</li>
                <li>must not be null!</li>
                <li>@param {Object=} opt_mayBeNull Optional (may be undefined), may be null. */ function strangeButTrue(nonNull, mayBeNull, opt_nonNull, opt_mayBeNull) { // ... }; Typedefs
                </li>
            </ul>
            <p>Sometimes types can get complicated. A function that accepts content for an Element might look like:</p>
            <p>/**</p>
            <ul>
                <li>@param {string} tagName</li>
                <li>@param {(string|Element|Text|Array.
                    <Element>|Array.
                        <Text>)} contents</li>
<li>@return {!Element}
*/
goog.createElement = function(tagName, contents) {
...
};
You can define commonly used type expressions with a @typedef tag. For example,</li>
</ul>
<p>/<em>* @typedef {(string|Element|Text|Array.<Element>|Array.<Text>)} </em>/
goog.ElementContent;</p>
<p>/**</p>
<ul>
<li>@param {string} tagName</li>
<li>@param {goog.ElementContent} contents</li>
<li>@return {!Element}
*/
goog.createElement = function(tagName, contents) {
...
};
Template types</li>
</ul>
<p>The compiler has limited support for template types. It can only infer the type of this inside an anonymous function literal from the type of the this argument and whether the this argument is missing.</p>
<p>/**</p>
<ul>
<li>@param {function(this:T, ...)} fn</li>
<li>@param {T} thisObj</li>
<li>@param {...*} var_args</li>
<li>@template T
*/
goog.bind = function(fn, thisObj, var_args) {
...
};
// Possibly generates a missing property warning.
goog.bind(function() { this.someProperty; }, new SomeClass());
// Generates an undefined this warning.
goog.bind(function() { this.someProperty; });</li>
</ul>
<h3 id="comments">Comments</h3>
<p>Use JSDoc
We follow the C++ style for comments in spirit.</p>
<p>All files, classes, methods and properties should be documented with JSDoc comments with the appropriate tags and types. Textual descriptions for properties, methods, method parameters and method return values should be included unless obvious from the property, method, or parameter name.</p>
<p>Inline comments should be of the // variety.</p>
<p>Complete sentences are recommended but not required. Complete sentences should use appropriate capitalization and punctuation.</p>
<p>Comment Syntax</p>
<p>The JSDoc syntax is based on JavaDoc. Many tools extract metadata from JSDoc comments to perform code validation and optimizations. These comments must be well-formed.</p>
<p>/**</p>
<ul>
<li>A JSDoc comment should begin with a slash and 2 asterisks.</li>
<li>Inline tags should be enclosed in braces like {@code this}.</li>
<li>@desc Block tags should always start on their own line.
*/
JSDoc Indentation</li>
</ul>
<p>If you have to line break a block tag, you should treat this as breaking a code statement and indent it four spaces.</p>
<p>/**</p>
<ul>
<li>Illustrates line wrapping for long param/return descriptions.</li>
<li>@param {string} foo This is a param with a description too long to fit in</li>
<li>one line.</li>
<li>@return {number} This returns something that has a description too long to</li>
<li>fit in one line.
*/
project.MyClass.prototype.method = function(foo) {
return 5;
};
You should not indent the @fileoverview command. You do not have to indent the @desc command.</li>
</ul>
<p>Even though it is not preferred, it is also acceptable to line up the description.</p>
<p>/**</p>
<ul>
<li>This is NOT the preferred indentation method.</li>
<li>@param {string} foo This is a param with a description too long to fit in</li>
<li>one line.</li>
<li>@return {number} This returns something that has a description too long to</li>
<li>fit in one line.
*/
project.MyClass.prototype.method = function(foo) {
return 5;
};
HTML in JSDoc</li>
</ul>
<p>Like JavaDoc, JSDoc supports many HTML tags, like <code>, <pre>, <tt>, <strong>, <ul>, <ol>, <li>, <a>, and others.</p>
<p>This means that plaintext formatting is not respected. So, don&#39;t rely on whitespace to format JSDoc:</p>
<p>/**</p>
<ul>
<li>Computes weight based on three factors:</li>
<li>items sent</li>
<li>items received</li>
<li>last timestamp
*/
It&#39;ll come out like this:</li>
</ul>
<p>Computes weight based on three factors: items sent items received last timestamp
Instead, do this:</p>
<p>/**</p>
<ul>
<li>Computes weight based on three factors:</li>
<li><ul></li>
<li><li>items sent</li>
<li><li>items received</li>
<li><li>last timestamp</li>
<li></ul>
*/
The JavaDoc style guide is a useful resource on how to write well-formed doc comments.
Top/File-Level Comments</li>
</ul>
<p>A copyright notice and author information are optional. File overviews are generally recommended whenever a file consists of more than a single class definition. The top level comment is designed to orient readers unfamiliar with the code to what is in this file. If present, it should provide a description of the file&#39;s contents and any dependencies or compatibility information. As an example:</p>
<p>/**</p>
<ul>
<li>@fileoverview Description of file, its uses and information</li>
<li>about its dependencies.
*/
Class Comments</li>
</ul>
<p>Classes must be documented with a description and a type tag that identifies the constructor.</p>
<p>/**</p>
<ul>
<li>Class making something fun and easy.</li>
<li>@param {string} arg1 An argument that makes this more interesting.</li>
<li>@param {Array.<number>} arg2 List of numbers to be processed.</li>
<li>@constructor</li>
<li>@extends {goog.Disposable}
*/
project.MyClass = function(arg1, arg2) {
// ...
};
goog.inherits(project.MyClass, goog.Disposable);
Method and Function Comments</li>
</ul>
<p>Parameter and return types should be documented. The method description may be omitted if it is obvious from the parameter or return type descriptions. Method descriptions should start with a sentence written in the third person declarative voice.</p>
<p>/**</p>
<ul>
<li>Operates on an instance of MyClass and returns something.</li>
<li>@param {project.MyClass} obj Instance of MyClass which leads to a long</li>
<li>comment that needs to be wrapped to two lines.</li>
<li>@return {boolean} Whether something occurred.
*/
function PR_someMethod(obj) {
// ...
}
Property Comments</li>
</ul>
<p>/<strong> @constructor */
project.MyClass = function() {
  /</strong></p>
<ul>
<li>Maximum number of things per pane.</li>
<li>@type {number}
*/
this.someProperty = 4;
}
JSDoc Tag Reference</li>
</ul>
<p>Tag Template &amp; Examples Description
@author @author username@google.com (first last)
For example:</p>
<p>/**</p>
<ul>
<li>@fileoverview Utilities for handling textareas.</li>
<li>@author kuth@google.com (Uthur Pendragon)
*/
Document the author of a file or the owner of a test, generally only used in the @fileoverview comment.
@code   {@code ...}
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>Moves to the next position in the selection.</li>
<li>Throws {@code goog.iter.StopIteration} when it</li>
<li>passes the end of the range.</li>
<li>@return {Node} The node at the next position.
*/
goog.dom.RangeIterator.prototype.next = function() {
// ...
};
Indicates that a term in a JSDoc description is code so it may be correctly formatted in generated documentation.
@const  @const
@const {type}
For example:</li>
</ul>
<p>/<em>* @const </em>/ var MY_BEER = &#39;stout&#39;;</p>
<p>/**</p>
<ul>
<li>My namespace&#39;s favorite kind of beer.</li>
<li>@const {string}
*/
mynamespace.MY_BEER = &#39;stout&#39;;</li>
</ul>
<p>/<em>* @const </em>/ MyClass.MY_BEER = &#39;stout&#39;;</p>
<p>/**</p>
<ul>
<li>Initializes the request.</li>
<li>@const
*/
mynamespace.Request.prototype.initialize = function() {
// This method cannot be overridden in a subclass.
};
Marks a variable (or property) as read-only and suitable for inlining.</li>
</ul>
<p>A @const variable is an immutable pointer to a value. If a variable or property marked as @const is overwritten, JSCompiler will give warnings.</p>
<p>The type declaration of a constant value can be omitted if it can be clearly inferred. An additional comment about the variable is optional.</p>
<p>When @const is applied to a method, it implies the method is not only not overwritable, but also that the method is finalized â€” not overridable in subclasses.</p>
<p>For more on @const, see the Constants section.</p>
<p>@constructor    @constructor
For example:</p>
<p>/**</p>
<ul>
<li>A rectangle.</li>
<li>@constructor
*/
function GM_Rect() {
...
}
Used in a class&#39;s documentation to indicate the constructor.
@define @define {Type} description
For example:</li>
</ul>
<p>/<em>* @define {boolean} </em>/
var TR_FLAGS_ENABLE_DEBUG = true;</p>
<p>/**</p>
<ul>
<li>@define {boolean} Whether we know at compile-time that</li>
<li>the browser is IE.
*/
goog.userAgent.ASSUME_IE = false;
Indicates a constant that can be overridden by the compiler at compile-time. In the example, the compiler flag --define=&#39;goog.userAgent.ASSUME_IE=true&#39; could be specified in the BUILD file to indicate that the constant goog.userAgent.ASSUME_IE should be replaced with true.
@deprecated @deprecated Description
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>Determines whether a node is a field.</li>
<li>@return {boolean} True if the contents of</li>
<li>the element are editable, but the element</li>
<li>itself is not.</li>
<li>@deprecated Use isField().
*/
BN_EditUtil.isTopEditableField = function(node) {
// ...
};
Used to tell that a function, method or property should not be used any more. Always provide instructions on what callers should use instead.
@dict   @dict Description
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>@constructor</li>
<li>@dict
*/
function Foo(x) {
this[&#39;x&#39;] = x;
}
var obj = new Foo(123);
var num = obj.x;  // warning</li>
</ul>
<p>(/<em>* @dict </em>/ { x: 1 }).x = 123;  // warning
When a constructor (Foo in the example) is annotated with @dict, you can only use the bracket notation to access the properties of Foo objects. The annotation can also be used directly on object literals.
@enum   @enum {Type}
For example:</p>
<p>/**</p>
<ul>
<li>Enum for tri-state values.</li>
<li>@enum {number}
*/
project.TriState = {
TRUE: 1,
FALSE: -1,
MAYBE: 0
};
@export @export
For example:</li>
</ul>
<p>/<em>* @export </em>/
foo.MyPublicClass.prototype.myPublicMethod = function() {
  // ...
};
Given the code on the left, when the compiler is run with the --generate_exports flag, it will generate the code:</p>
<p>goog.exportSymbol(&#39;foo.MyPublicClass.prototype.myPublicMethod&#39;,
    foo.MyPublicClass.prototype.myPublicMethod);
which will export the symbols to uncompiled code. Code that uses the @export annotation must either</p>
<p>include //javascript/closure/base.js, or
define both goog.exportSymbol and goog.exportProperty with the same method signature in their own codebase.
@expose @expose
For example:</p>
<p>/<em>* @expose </em>/
MyClass.prototype.exposedProperty = 3;
Declares an exposed property. Exposed properties will not be removed, or renamed, or collapsed, or optimized in any way by the compiler. No properties with the same name will be able to be optimized either.</p>
<p>@expose should never be used in library code, because it will prevent that property from ever getting removed.</p>
<p>@extends    @extends Type
@extends {Type}
For example:</p>
<p>/**</p>
<ul>
<li>Immutable empty node list.</li>
<li>@constructor</li>
<li>@extends goog.ds.BasicNodeList
*/
goog.ds.EmptyNodeList = function() {
...
};
Used with @constructor to indicate that a class inherits from another class. Curly braces around the type are optional.
@externs    @externs
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>@fileoverview This is an externs file.</li>
<li>@externs
*/</li>
</ul>
<p>var document;
Declares an externs file.</p>
<p>@fileoverview   @fileoverview Description
For example:</p>
<p>/**</p>
<ul>
<li>@fileoverview Utilities for doing things that require this very long</li>
<li>but not indented comment.</li>
<li>@author kuth@google.com (Uthur Pendragon)
*/
Makes the comment block provide file level information.
@implements @implements Type
@implements {Type}
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>A shape.</li>
<li>@interface
*/
function Shape() {};
Shape.prototype.draw = function() {};</li>
</ul>
<p>/**</p>
<ul>
<li>@constructor</li>
<li>@implements {Shape}
*/
function Square() {};
Square.prototype.draw = function() {
...
};
Used with @constructor to indicate that a class implements an interface. Curly braces around the type are optional.
@inheritDoc @inheritDoc
For example:</li>
</ul>
<p>/<em>* @inheritDoc </em>/
project.SubClass.prototype.toString() {
  // ...
};
Deprecated. Use @override instead.</p>
<p>Indicates that a method or property of a subclass intentionally hides a method or property of the superclass, and has exactly the same documentation. Notice that @inheritDoc implies @override
@interface  @interface
For example:</p>
<p>/**</p>
<ul>
<li>A shape.</li>
<li>@interface
*/
function Shape() {};
Shape.prototype.draw = function() {};</li>
</ul>
<p>/**</p>
<ul>
<li>A polygon.</li>
<li>@interface</li>
<li>@extends {Shape}
*/
function Polygon() {};
Polygon.prototype.getSides = function() {};
Used to indicate that the function defines an interface.
@lends  @lends objectName
@lends {objectName}
For example:</li>
</ul>
<p>goog.object.extend(
    Button.prototype,
    /<em>* @lends {Button.prototype} </em>/ {
      isButton: function() { return true; }
    });
Indicates that the keys of an object literal should be treated as properties of some other object. This annotation should only appear on object literals.
Notice that the name in braces is not a type name like in other annotations. It&#39;s an object name. It names the object on which the properties are &quot;lent&quot;. For example, @type {Foo} means &quot;an instance of Foo&quot;, but @lends {Foo} means &quot;the constructor Foo&quot;.
The JSDoc Toolkit docs have more information on this annotation.
@license or @preserve   @license Description
For example:</p>
<p>/**</p>
<ul>
<li>@preserve Copyright 2009 SomeThirdParty.</li>
<li>Here is the full license text and copyright</li>
<li>notice for this file. Note that the notice can span several</li>
<li>lines and is only terminated by the closing star and slash:
*/
Anything marked by @license or @preserve will be retained by the compiler and output at the top of the compiled code for that file. This annotation allows important notices (such as legal licenses or copyright text) to survive compilation unchanged. Line breaks are preserved.
@noalias    @noalias
For example:</li>
</ul>
<p>/<em>* @noalias </em>/
function Range() {}
Used in an externs file to indicate to the compiler that the variable or function should not be aliased as part of the alias externals pass of the compiler.
@nocompile  @nocompile
For example:</p>
<p>/<em>* @nocompile </em>/</p>
<p>// JavaScript code
Used at the top of a file to tell the compiler to parse this file but not compile it. Code that is not meant for compilation and should be omitted from compilation tests (such as bootstrap code) uses this annotation. Use sparingly.
@nosideeffects  @nosideeffects
For example:</p>
<p>/<em>* @nosideeffects </em>/
function noSideEffectsFn1() {
  // ...
}</p>
<p>/<em>* @nosideeffects </em>/
var noSideEffectsFn2 = function() {
  // ...
};</p>
<p>/<em>* @nosideeffects </em>/
a.prototype.noSideEffectsFn3 = function() {
  // ...
};
This annotation can be used as part of function and constructor declarations to indicate that calls to the declared function have no side-effects. This annotation allows the compiler to remove calls to these functions if the return value is not used.
@override   @override
For example:</p>
<p>/**</p>
<ul>
<li>@return {string} Human-readable representation of project.SubClass.</li>
<li>@override
*/
project.SubClass.prototype.toString = function() {
// ...
};
Indicates that a method or property of a subclass intentionally hides a method or property of the superclass. If no other documentation is included, the method or property also inherits documentation from its superclass.
@param  @param {Type} varname Description
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>Queries a Baz for items.</li>
<li>@param {number} groupNum Subgroup id to query.</li>
<li>@param {string|number|null} term An itemName,</li>
<li>or itemId, or null to search everything.
*/
goog.Baz.prototype.query = function(groupNum, term) {
// ...
};
Used with method, function and constructor calls to document the arguments of a function.
Type names must be enclosed in curly braces. If the type is omitted, the compiler will not type-check the parameter.
@private    @private
@private {type}
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>Handlers that are listening to this logger.</li>
<li>@private {!Array.<Function>}
*/
this.handlers_ = [];
Used in conjunction with a trailing underscore on the method or property name to indicate that the member is private and final.
@protected  @protected
@protected {type}
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>Sets the component&#39;s root element to the given element.</li>
<li>@param {Element} element Root element for the component.</li>
<li>@protected
*/
goog.ui.Component.prototype.setElementInternal = function(element) {
// ...
};
Used to indicate that the member or property is protected. Should be used in conjunction with names with no trailing underscore.
@public @public
@public {type}
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>Whether to cancel the event in internal capture/bubble processing.</li>
<li>@public {boolean}</li>
<li>@suppress {visiblity} Referencing this outside this package is strongly</li>
<li>discouraged.
*/
goog.events.Event.prototype.propagationStopped_ = false;
Used to indicate that the member or property is public. Variables and properties are public by default, so this annotation is rarely necessary. Should only be used in legacy code that cannot be easily changed to override the visibility of members that were named as private variables.
@return @return {Type} Description
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>@return {string} The hex ID of the last item.
*/
goog.Baz.prototype.getLastId = function() {
// ...
return id;
};
Used with method and function calls to document the return type. When writing descriptions for boolean parameters, prefer &quot;Whether the component is visible&quot; to &quot;True if the component is visible, false otherwise&quot;. If there is no return value, do not use an @return tag.
Type names must be enclosed in curly braces. If the type is omitted, the compiler will not type-check the return value.
@see    @see Link
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>Adds a single item, recklessly.</li>
<li>@see #addSafely</li>
<li>@see goog.Collect</li>
<li>@see goog.RecklessAdder#add
...
Reference a lookup to another class function or method.
@struct @struct Description
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>@constructor</li>
<li>@struct
*/
function Foo(x) {
this.x = x;
}
var obj = new Foo(123);
var num = obj[&#39;x&#39;];  // warning
obj.y = &quot;asdf&quot;;  // warning</li>
</ul>
<p>Foo.prototype = /<em>* @struct </em>/ {
  method1: function() {}
};
Foo.prototype.method2 = function() {};  // warning
When a constructor (Foo in the example) is annotated with @struct, you can only use the dot notation to access the properties of Foo objects. Also, you cannot add new properties to Foo objects after they have been created. The annotation can also be used directly on object literals.
@supported  @supported Description
For example:</p>
<p>/**</p>
<ul>
<li>@fileoverview Event Manager</li>
<li>Provides an abstracted interface to the</li>
<li>browsers&#39; event systems.</li>
<li>@supported So far tested in IE6 and FF1.5
*/
Used in a fileoverview to indicate what browsers are supported by the file.
@suppress   @suppress {warning1|warning2} @suppress {warning1,warning2}
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>@suppress {deprecated}
*/
function f() {
deprecatedVersionOfF();
}
Suppresses warnings from tools. Warning categories are separated by | or ,.
@template   @template
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>@param {function(this:T, ...)} fn</li>
<li>@param {T} thisObj</li>
<li>@param {...*} var_args</li>
<li>@template T
*/
goog.bind = function(fn, thisObj, var_args) {
...
};
This annotation can be used to declare a template typename.
@this   @this Type
@this {Type}
For example:</li>
</ul>
<p>pinto.chat.RosterWidget.extern(&#39;getRosterElement&#39;,
/**</p>
<ul>
<li>Returns the roster widget element.</li>
<li>@this pinto.chat.RosterWidget</li>
<li>@return {Element}
*/
function() {
return this.getWrappedComponent_().getElement();
});
The type of the object in whose context a particular method is called. Required when the this keyword is referenced from a function that is not a prototype method.
@type   @type Type
@type {Type}
For example:</li>
</ul>
<p>/**</p>
<ul>
<li>The message hex ID.</li>
<li>@type {string}
*/
var hexId = hexId;
Identifies the type of a variable, property, or expression. Curly braces are not required around most types, but some projects mandate them for all types, for consistency.
@typedef    @typedef
For example:</li>
</ul>
<p>/<em>* @typedef {(string|number)} </em>/
goog.NumberLike;</p>
<p>/<em>* @param {goog.NumberLike} x A number or a string. </em>/
goog.readNumber = function(x) {
  ...
}
This annotation can be used to declare an alias of a more complex type.
You may also see other types of JSDoc annotations in third-party code. These annotations appear in the JSDoc Toolkit Tag Reference but are currently discouraged in Google code. You should consider them &quot;reserved&quot; names for future use. These include:</p>
<p>@augments
@argument
@borrows
@class
@constant
@constructs
@default
@event
@example
@field
@function
@ignore
@inner
@link
@memberOf
@name
@namespace
@property
@public
@requires
@returns
@since
@static
@version</p>
<h3 id="providing-dependencies-with-goog-provide">Providing Dependencies With goog.provide</h3>
<p>Only provide top-level symbols.
All members defined on a class should be in the same file. So, only top-level classes should be provided in a file that contains multiple members defined on the same class (e.g. enums, inner classes, etc).</p>
<p>Do this:</p>
<p>goog.provide(&#39;namespace.MyClass&#39;);
Not this:</p>
<p>goog.provide(&#39;namespace.MyClass&#39;);
goog.provide(&#39;namespace.MyClass.Enum&#39;);
goog.provide(&#39;namespace.MyClass.InnerClass&#39;);
goog.provide(&#39;namespace.MyClass.TypeDef&#39;);
goog.provide(&#39;namespace.MyClass.CONSTANT&#39;);
goog.provide(&#39;namespace.MyClass.staticMethod&#39;);
Members on namespaces may also be provided:</p>
<p>goog.provide(&#39;foo.bar&#39;);
goog.provide(&#39;foo.bar.method&#39;);
goog.provide(&#39;foo.bar.CONSTANT&#39;);</p>
<h3 id="compiling">Compiling</h3>
<p>Required
Use of JS compilers such as the Closure Compiler is required for all customer-facing code.</p>
<h3 id="tips-and-tricks">Tips and Tricks</h3>
<p>JavaScript tidbits
True and False Boolean Expressions</p>
<p>The following are all false in boolean expressions:</p>
<p>null
undefined
&#39;&#39; the empty string
0 the number
But be careful, because these are all true:</p>
<p>&#39;0&#39; the string
[] the empty array
{} the empty object
This means that instead of this:</p>
<p>while (x != null) {
you can write this shorter code (as long as you don&#39;t expect x to be 0, or the empty string, or false):</p>
<p>while (x) {
And if you want to check a string to see if it is null or empty, you could do this:</p>
<p>if (y != null &amp;&amp; y != &#39;&#39;) {
But this is shorter and nicer:</p>
<p>if (y) {
Caution: There are many unintuitive things about boolean expressions. Here are some of them:</p>
<p>Boolean(&#39;0&#39;) == true
&#39;0&#39; != true
0 != null
0 == []
0 == false
Boolean(null) == false
null != true
null != false
Boolean(undefined) == false
undefined != true
undefined != false
Boolean([]) == true
[] != true
[] == false
Boolean({}) == true
{} != true
{} != false
Conditional (Ternary) Operator (?:)</p>
<p>Instead of this:</p>
<p>if (val) {
  return foo();
} else {
  return bar();
}
you can write this:</p>
<p>return val ? foo() : bar();
The ternary conditional is also useful when generating HTML:</p>
<p>var html = &#39;<input type="checkbox"' +
    (isChecked ? ' checked' : '') +
    (isEnabled ? '' : ' disabled') +
    ' name="foo">&#39;;
&amp;&amp; and ||</p>
<p>These binary boolean operators are short-circuited, and evaluate to the last evaluated term.</p>
<p>&quot;||&quot; has been called the &#39;default&#39; operator, because instead of writing this:</p>
<p>/<em>* @param {</em>=} opt_win */
function foo(opt_win) {
  var win;
  if (opt_win) {
    win = opt_win;
  } else {
    win = window;
  }
  // ...
}
you can write this:</p>
<p>/<em>* @param {</em>=} opt_win */
function foo(opt_win) {
  var win = opt_win || window;
  // ...
}
&quot;&amp;&amp;&quot; is also useful for shortening code. For instance, instead of this:</p>
<p>if (node) {
  if (node.kids) {
    if (node.kids[index]) {
      foo(node.kids[index]);
    }
  }
}
you could do this:</p>
<p>if (node &amp;&amp; node.kids &amp;&amp; node.kids[index]) {
  foo(node.kids[index]);
}
or this:</p>
<p>var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];
if (kid) {
  foo(kid);
}
However, this is going a little too far:</p>
<p>node &amp;&amp; node.kids &amp;&amp; node.kids[index] &amp;&amp; foo(node.kids[index]);
Iterating over Node Lists</p>
<p>Node lists are often implemented as node iterators with a filter. This means that getting a property like length is O(n), and iterating over the list by re-checking the length will be O(n^2).</p>
<p>var paragraphs = document.getElementsByTagName(&#39;p&#39;);
for (var i = 0; i &lt; paragraphs.length; i++) {
  doSomething(paragraphs[i]);
}
It is better to do this instead:</p>
<p>var paragraphs = document.getElementsByTagName(&#39;p&#39;);
for (var i = 0, paragraph; paragraph = paragraphs[i]; i++) {
  doSomething(paragraph);
}
This works well for all collections and arrays as long as the array does not contain things that are treated as boolean false.</p>
<p>In cases where you are iterating over the childNodes you can also use the firstChild and nextSibling properties.</p>
<p>var parentNode = document.getElementById(&#39;foo&#39;);
for (var child = parentNode.firstChild; child; child = child.nextSibling) {
  doSomething(child);
}</p>
<h2 id="parting-words">Parting Words</h2>
<p><em>BE CONSISTENT.</em></p>
<p>If you&#39;re editing code, take a few minutes to look at the code around you and determine its style. If they use spaces around all their arithmetic operators, you should too. If their comments have little boxes of hash marks around them, make your comments have little boxes of hash marks around them too.</p>
<p>The point of having style guidelines is to have a common vocabulary of coding so people can concentrate on what you&#39;re saying rather than on how you&#39;re saying it. We present global style rules here so people know the vocabulary, but local style is also important. If code you add to a file looks drastically different from the existing code around it, it throws readers out of their rhythm when they go to read it. Avoid this.</p>
        </article>
    </div>
</body>
</html>